/* Autogenerated with Kurento Idl */

/*
 * (C) Copyright 2013-2014 Kurento (http://kurento.org/)
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the GNU Lesser General Public License
 * (LGPL) version 2.1 which accompanies this distribution, and is available at
 * http://www.gnu.org/licenses/lgpl-2.1.html
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 */

var inherits = require('inherits');

var Promise = require('es6-promise').Promise;

var promiseCallback = require('promisecallback');

var checkParams = require('checktype').checkParams;

var kurentoClient = require('kurento-client');
var register = kurentoClient.register;

/**
 * Get the constructor for a type
 *
 * If the type is not registered, use generic {MediaObject}
 */
function getConstructor(type)
{
  var result = register.classes[type] || register.abstracts[type];
  if(result) return result;

  console.warn("Unknown type '"+type+"', using MediaObject instead");
  return MediaObject;
};

var ChecktypeError = require('checktype').ChecktypeError;

var MediaObject = require('./abstracts/MediaObject');

/**
 * Create a {@link module:core.MediaPipeline MediaPipeline}
 *
 * @classdesc
 *  A pipeline is a container for a collection of {@link module:core/abstracts.MediaElement MediaElements} and :rom:cls:`MediaMixers<MediaMixer>`. It offers the methods needed to control the creation and connection of elements inside a certain pipeline.
 *
 * @extends module:core/abstracts.MediaObject
 *
 * @constructor module:core.MediaPipeline
 */
function MediaPipeline(){
  MediaPipeline.super_.call(this);


  var self = this;


  // Transactional API

  var transactions = [];

  function transactionOperation(method, params, callback)
  {
    var message =
    {
      method: method,
      params: params,
      callback: callback
    }

    transactions[0].push(message);
  }

  this.beginTransaction = function()
  {
    transactions.unshift([]);
  };

  this.endTransaction = function(callback)
  {
    var operations = transactions.shift();

    var promise = new Promise(function(resolve, reject)
    {
      function callback(error, result)
      {
        if(error) return reject(error);

        resolve(result)
      };

      encodeTransaction({operations: operations}, callback);
    })

    return promiseCallback(promise, callback)
  };

  this.transaction = function(transaction, callback)
  {
    this.beginTransaction();
    transaction.call(this);
    return this.endTransaction(callback);
  };


  // Encode commands

  function encodeCreate(params, callback)
  {
    if(transactions.length)
      transactionOperation('create', params, callback);
    else
      self.emit('_create', params, callback)
  }

  function encodeRpc(method, params, callback)
  {
    if(transactions.length)
      transactionOperation(method, params, callback);
    else
      self.emit('_rpc', method, params, callback)
  }

  function encodeTransaction(params, callback)
  {
    if(transactions.length)
      transactionOperation('transaction', params, callback);
    else
      self.then(function()
      {
        params.object = self.id;

        self.emit('_transaction', params, callback);
      })
  }


  /**
   * Request to the server to create a new MediaElement
   */
  function createMediaObject(item, callback)
  {
    var constructor = getConstructor(item.type);

    if(constructor.create)
    {
      item = constructor.create(item.params);

      // Apply inheritance
      var prototype = constructor.prototype;
      inherits(constructor, getConstructor(item.type));
      extend(constructor.prototype, prototype);
    };

    item.params.mediaPipeline = self;

    item.constructorParams = checkParams(item.params,
                                         constructor.constructorParams,
                                         item.type);
    delete item.params;

    var mediaObject = new constructor()

    /**
     * Request a generic functionality to be procesed by the server
     */
    mediaObject.on('_rpc', function(method, params, callback)
    {
      params.object = mediaObject;

      encodeRpc(method, params, callback);
    });

    if(mediaObject instanceof Hub)
      mediaObject.on('_create', encodeCreate);

    Object.defineProperty(item, 'object', {value: mediaObject});

    encodeCreate(item, callback);

    return mediaObject
  };

  /**
   * Create a new instance of a {module:core/abstract.MediaObject} attached to
   *  this {module:core.MediaPipeline}
   *
   * @param {external:String} type - Type of the
   *  {module:core/abstract.MediaObject}
   * @param {external:String[]} [params]
   * @param {module:core.MediaPipeline~createCallback} callback
   *
   * @return {external:Promise}
   */
  this.create = function(type, params, callback){
    // Fix optional parameters
    if(params instanceof Function){
      if(callback)
        throw new SyntaxError("Nothing can be defined after the callback");

      callback = params;
      params = undefined;
    };

    params = params || {};

    if(type instanceof Array)
      return createPromise(type, createMediaObject, callback)

    type = {params: params, type: type};

    return createMediaObject(type, callback)
  };
  /**
   * @callback core.MediaPipeline~createCallback
   * @param {external:Error} error
   * @param {module:core/abstract~MediaElement} result
   *  The created MediaElement
   */
};
inherits(MediaPipeline, MediaObject);

/**
 * @alias module:core.MediaPipeline.constructorParams
 */
MediaPipeline.constructorParams = {};

/**
 * @alias module:core.MediaPipeline.events
 *
 * @extend module:core/abstracts.MediaObject.events
 */
MediaPipeline.events = MediaObject.events;

module.exports = MediaPipeline;

MediaPipeline.check = function(key, value)
{
  if(!(value instanceof MediaPipeline))
    throw ChecktypeError(key, MediaPipeline, value);
};
